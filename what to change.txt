=== ПОПЫТКА 1 ===

1. Вывод информации по тегам: 
    
+    В данный момент, если идет запрос по 2м тегам, то осуществляется 2 запроса к БД, а потом уже идет сравнение масивов и вывод нужного. 
+    Вопросы из-за этого:
+        1. Будет ли работать, при условии нескольких результатов с одинаковыми тегами?
+            Комментарий: в принципе должно, ибо по логике кода, при ЛЮБЫХ одинаковых массивах, полученных в р-те 2х запросов, происходит
+                их добавление в результатирующий. 
+        2. Дописать механику проверки количества тегов и как следствие необходимыз запросов. 
+            Комментарий: при наличии 2х и более тегов, функция должна вызываться все равно ЕДИНОЖДЫ. 
+                Лучше будет добавить вызов функции поиска в БД в отдельную функцию. 
+    Хотя лучше разобраться в логике запроса и выводить сразу необходимую информацию.

Реализованно:
    Запрос к БД и группировка выводных данных на стороне sql. 
        Комментарий: сильно ли "тяжелая" функция having?
/        1. Не самый удобный способ запроса. Можно ли сделать удобнее?
            Комментарий: Вероятнее всего да, првоерить сохраненное. Вопрос будет с добавлением строк, что, в принципе, решаемо функцией.
+        2. Проверить вывод информации при 2 тегах из 3х необходимых.
+        3. Проерить вывод нескольких строк с одинаковыми несколькими тегами. 
+        4. Капс в запросе к тегу?
            Ответ: не важен.


2. Необходима форма для добавление новой информации в БД. 

    Логика:
        В начале надо проверить новые теги на предмет их наличия в БД. 
+            1. Если теги есть, то надо вытащить их id_teg 
+            2. Если тегов нет, то создаются новые и вытаскиваются их id_teg. 
                Комментарий: не идеально реализованно: после КАЖДОГО внесения я запрашиваю новые айди. 
+        Далее идет добавление информации в таблицу main? 
+        После - создание связи в compound.


3.   Хранение результирующий данных при выводе из БД. 

    1. Хранить их в виде массива или в виде объектов?     

4.  Обращение к разным классам
    Комментарий: мне не нравится необходимость создавания разных классов.



=== ПОПЫТКА 2 ===

+- (других вариантов при наличии трейта не вижу)
1. Трейт DB
    Не инициализируется его контруктор, приходится осуществлять подключение ДБ с помощью функции 
        (хотя __деструктор работает корректно)
        Возможно ошибка в одинаковом названии __construct?
!!        Комментарий: советуют полностью избегать использование конструктора в трейтах
    Реализованно: происходит ручной вызов контруктора и деструктора в каждом из классе, работающих с DB


+
2. Передача данных на добавление в ДБ

+    1. При создании тегов данные передавать не получается, поэтому в 1 функции осуществляется запрос к 
        хранилищу. При создании пункта main в обоих функциях осуществляется одинаковые запросы касаемо
        вопроса и ответа. 
        Есть ли смысл их осуществить в главной функции и передавать уже значения?

        Ответ: есть. Повторяющиеся куски кода надо убирать.
+    2. Вызов compoundAdjuster()
        Если я вызываю эту f() из главной, то может происходить дублирование информации о паре тегов даже при уславии полного соответствия
            пары вопрос/ответ. Поэтому выглядит логичным вызов compoundAdjuster() из mainAdjuster()



3. Нужен более разный вывод информации.

    1. Если добавляется уже существующая пара, то надо писать "уже есть данная запись"?
    2. Если добавляется такой же вопрос, но с другим ответом, надо писать "вопрос дополнен"?
    3. Если добавляется уже существующая пара но с другими тегами, то выводится пара с новыми тегами, тогда как обновление их не происходит
    4. Если вбить 2 одинаковых тега в поиске, то будет выведен NULL


+
4. Пероидически вываливается правый блок.
    
    Комментарий: От пропадает, если выводится ошибка о не найденной информации.
    Решено: добавляется значение nothing в результатирующий массив, на это значение осуществляется проверка в header.php